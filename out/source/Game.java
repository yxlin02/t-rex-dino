/* autogenerated by Processing revision 1306 on 2025-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

/*
 * Dinosaur T-Rex Game from Google Chrome - Processing Implementation
 * 
 * Controls:
 * - Press SPACE or UP ARROW to jump
 * - Press R to restart game
 * - Press N for next level (when available)
 * 
 * Game Objective: Jump over obstacles and survive as long as possible!
 * Score increases over time and with each obstacle passed.
 */

// Game state management
int gameState = 0; // 0 = menu, 1 = playing, 2 = game over, 3 = level complete
int currentLevel = 1; // Starting at level 1 
int maxLevels = 3; // Maximum number of levels

// Game variables
float score = 0; // Score for current level
float totalScore = 0; // Cumulative score across all levels
float highScore = 0; // Highest score achieved
float gameSpeed = 5; // Increased base speed for better jumpability
float groundY; // Height of the ground
int gameTime = 0;
int levelTime = 0; // Time for current level

// Debug mode for hit box visualization
boolean debugMode = false; // Set to true to show hit boxes

// Dinosaur character
Dinosaur dino;

// Obstacle management
ArrayList<Obstacle> obstacles;
float obstacleTimer = 0; // Time since last obstacle was spawned
float obstacleInterval = 120; // frames between obstacles

// Visual elements
int skyColor = color(135, 206, 235); // Sky blue
int groundColor = color(139, 69, 19); // Brown ground
int dinoColor = color(0, 100, 0); // Dark green

// Image assets
PImage dinoSprite;
PImage smallCactusSprite;
PImage bigCactusSprite;
PImage backgroundImg;
PImage groundTexture;

// Sound effects using Minim library


Minim minim;
AudioPlayer jumpSound;
AudioPlayer collisionSound;

// Game setup
public void setup() {
  /* size commented out by preprocessor */;
  groundY = height - 50;
  
  // Load image assets
  createImageAssets();
  
  // Initialize Minim and load sound effects
  minim = new Minim(this);
  loadSoundEffects();
  
  // Initialize game objects
  dino = new Dinosaur(100, groundY);
  obstacles = new ArrayList<Obstacle>();
  
  // Set initial game state
  gameState = 0; // Start with menu
}

// Load image assets from data folder
public void createImageAssets() {
  // Load dinosaur sprite
  dinoSprite = loadImage("data/t-rex dino.png");
  
  // Load cactus sprites
  smallCactusSprite = loadImage("data/small cactus.png");
  bigCactusSprite = loadImage("data/big cactus.png");
  
  // Create background image 
  backgroundImg = createImage(width, height, RGB);
  backgroundImg.loadPixels();
  for (int i = 0; i < backgroundImg.pixels.length; i++) {
    backgroundImg.pixels[i] = color(135, 206, 235); // Sky blue
  }
  backgroundImg.updatePixels();
  
  // Create ground texture
  groundTexture = createImage(width, 50, RGB);
  groundTexture.loadPixels();
  for (int i = 0; i < groundTexture.pixels.length; i++) {
    groundTexture.pixels[i] = color(139, 69, 19); // Brown
  }
  groundTexture.updatePixels();
}

// Load sound effects from data folder using Minim
public void loadSoundEffects() {
  try {
    // Load sound files using Minim
    jumpSound = minim.loadFile("data/jump.mp3");
    collisionSound = minim.loadFile("data/game-over-arcade.wav");
    println("Sound effects loaded successfully");
  } catch (Exception e) {
    println("Could not load sound effects: " + e.getMessage());
    jumpSound = null;
    collisionSound = null;
  }
}

// Main game loop
public void draw() {
  background(skyColor);
  
  // Draw ground
  fill(groundColor);
  rect(0, groundY, width, height - groundY);
  
  // Handle different game states
  switch(gameState) {
    case 0:
      drawMenu();
      break;
    case 1:
      playGame();
      break;
    case 2:
      drawGameOver();
      break;
    case 3:
      drawLevelComplete();
      break;
  }
}

// Menu screen
public void drawMenu() {
  fill(0);
  textAlign(CENTER);
  textSize(32);
  text("DINOSAUR T-REX GAME", width/2, height/2 - 50);
  
  textSize(18);
  text("Press SPACE to start!", width/2, height/2);
  text("Use SPACE or UP ARROW to jump", width/2, height/2 + 30);
  text("Avoid obstacles to survive!", width/2, height/2 + 50);
  
  textSize(14);
  text("High Score: " + PApplet.parseInt(highScore), width/2, height/2 + 80);
}

// Main game logic
public void playGame() {
  // Update game time and score
  gameTime++;
  levelTime++;
  score += 0.1f; // Score increases over time
  totalScore += 0.1f; // Cumulative score across levels
  
  // Update dinosaur
  dino.update();
  dino.display();
  
  // Generate cactus chunks with proper spacing
  obstacleTimer++;
  if (obstacleTimer >= obstacleInterval) {
    // Check if it's safe to spawn a new chunk (not too close to dinosaur)
    float dinoDistance = width - dino.x;
    if (dinoDistance > 120) { // Only spawn if dinosaur has enough space
      
      // Generate a cactus chunk (1-3 consecutive cacti)
      int chunkSize = PApplet.parseInt(random(1, 4)); // 1, 2, or 3 cacti in chunk
      float chunkStartX = width;
      
      // Create the chunk of cacti with wider spacing for jumpability
      for (int i = 0; i < chunkSize; i++) {
        obstacles.add(new Obstacle(chunkStartX + (i * 40), groundY)); // 40px spacing between cacti in chunk
      }
      
      // Calculate total chunk width (for spacing calculation)
      float chunkWidth = (chunkSize - 1) * 40 + 25; // Total width of the chunk
      
      // Set next spawn interval based on chunk size
      // Larger chunks need more space after them
      if (chunkSize == 1) {
        obstacleInterval = PApplet.parseInt(random(80, 120)) - (currentLevel - 1) * 10;
      } else if (chunkSize == 2) {
        obstacleInterval = PApplet.parseInt(random(100, 140)) - (currentLevel - 1) * 10;
      } else { // chunkSize == 3
        obstacleInterval = PApplet.parseInt(random(120, 160)) - (currentLevel - 1) * 10;
      }
      
      obstacleInterval = max(60, obstacleInterval); // minimum spacing between chunks
    }
    
    obstacleTimer = 0;
  }
  
  // Update and display obstacles
  for (int i = obstacles.size() - 1; i >= 0; i--) {
    Obstacle obs = obstacles.get(i);
    obs.update();
    obs.display();
    
    // Remove obstacles that are off screen
    if (obs.x + obs.width < 0) {
      obstacles.remove(i);
      score += 10; // Bonus points for passing obstacles
      totalScore += 10; // Add to cumulative score
    }
    
    // Check collision
    if (dino.checkCollision(obs)) {
      gameState = 2; // Game over
      if (score > highScore) {
        highScore = score;
      }
      
      // Play collision sound effect
      if (collisionSound != null) {
        collisionSound.rewind();
        collisionSound.play();
      }
    }
  }
  
  // Check level completion with progressive level lengths
  int levelDuration = 1800 + (currentLevel - 1) * 600; // 30s + 10s per level
  if (levelTime > levelDuration) {
    gameState = 3; // Level complete
  }
  
  // Display UI
  drawUI();
}

// Game over screen
public void drawGameOver() {
  fill(255, 0, 0);
  textAlign(CENTER);
  textSize(32);
  text("GAME OVER", width/2, height/2 - 50);
  
  textSize(18);
  text("Level Score: " + PApplet.parseInt(score), width/2, height/2);
  text("Total Score: " + PApplet.parseInt(totalScore), width/2, height/2 + 25);
  text("Press R to restart this level", width/2, height/2 + 80);
  text("Press SPACE for menu", width/2, height/2 + 105);
}

// Level complete screen
public void drawLevelComplete() {
  fill(0, 0, 0);
  textAlign(CENTER);
  textSize(32);
  text("LEVEL " + currentLevel + " COMPLETE!", width/2, height/2 - 50);
  
  textSize(18);
  text("Level Score: " + PApplet.parseInt(score), width/2, height/2);
  text("Total Score: " + PApplet.parseInt(totalScore), width/2, height/2 + 25);
  
  if (currentLevel < maxLevels) {
    text("Press N for next level", width/2, height/2 +80);
  } else {
    text("CONGRATULATIONS! You beat all levels!", width/2, height/2 + 80);
  }
  text("Press R to restart this level", width/2, height/2 + 100);
}

// Display game UI
public void drawUI() {
  fill(0);
  textAlign(LEFT);
  textSize(16);
  text("Level Score: " + PApplet.parseInt(score), 20, 30);
  text("Total Score: " + PApplet.parseInt(totalScore), 20, 50);
  text("Level: " + currentLevel, 20, 70);
  text("Time: " + (levelTime/60), 20, 90);
  
  // Debug info
  if (debugMode) {
    textSize(12);
    text("DEBUG MODE ON", 20, 120);
    text("Press D to toggle", 20, 140);
    text("Dino Size: " + PApplet.parseInt(dino.size), 20, 160);
    text("Obstacles: " + obstacles.size(), 20, 180);
  }
}

// Handle keyboard input
public void keyPressed() {
  // Debug toggle 
  if (key == 'd' || key == 'D') {
    debugMode = !debugMode;
  }
  
  switch(gameState) {
    case 0: // Menu
      if (key == ' ' || keyCode == UP) {
        startGame();
      }
      break;
    case 1: // Playing
      if (key == ' ' || keyCode == UP) {
        dino.jump();
      }
      break;
    case 2: // Game over
      if (key == 'r' || key == 'R') {
        restartGame();
      } else if (key == ' ') {
        gameState = 0; // Back to menu
      }
      break;
    case 3: // Level complete
      if (key == 'n' || key == 'N') {
        nextLevel();
      } else if (key == 'r' || key == 'R') {
        restartGame();
      }
      break;
  }
}

// Start new game
public void startGame() {
  gameState = 1;
  currentLevel = 1;
  score = 0;
  totalScore = 0; // Reset cumulative score
  gameTime = 0;
  levelTime = 0; // Reset level time
  gameSpeed = 5; // Increased base speed
  obstacleInterval = 120;
  obstacles.clear();
  dino.reset();
}

// Restart current game
public void restartGame() {
  gameState = 1;
  score = 0;
  levelTime = 0; // Reset level time
  gameSpeed = 5 + (currentLevel - 1) * 1.5f; // Increase speed for higher levels
  obstacleInterval = max(60, 120 - (currentLevel - 1) * 20);
  obstacles.clear();
  dino.reset();
}

// Advance to next level
public void nextLevel() {
  currentLevel++;
  if (currentLevel <= maxLevels) {
    gameState = 1;
    score = 0; // Reset level score
    levelTime = 0; // Reset level time for new level
    gameSpeed = 5 + (currentLevel - 1) * 1.5f;
    obstacleInterval = max(60, 120 - (currentLevel - 1) * 20);
    obstacles.clear();
    dino.reset();
  }
}

// Dinosaur class
class Dinosaur {
  float x, y;
  float velocity;
  float gravity = 0.9f; // gravity for better jump control
  boolean isJumping = false;
  float size = 50; // Made dinosaur bigger
  
  Dinosaur(float x, float y) {
    this.x = x;
    this.y = y - size/2; // Position so bottom of dinosaur touches ground
    this.velocity = 0;
  }
  
  public void update() {
    // Apply gravity
    if (isJumping || y < groundY - size/2) {
      velocity += gravity;
      y += velocity;
      
      // Land on ground (dinosaur bottom touches ground)
      if (y >= groundY - size/2) {
        y = groundY - size/2;
        velocity = 0;
        isJumping = false;
      }
    }
  }
  
  public void jump() {
    if (!isJumping) {
      velocity = -22; // increased jump force for clearing 3 consecutive cacti
      isJumping = true;
      
      // Play jump sound effect 
      if (jumpSound != null) {
        jumpSound.rewind(); // Reset to beginning first
        jumpSound.cue(1000); // Start at 0.25 seconds (250 milliseconds)
        jumpSound.play();
      }
    }
  }
  
  public void display() {
    // Use real dinosaur sprite if available, otherwise draw simple shape
    if (dinoSprite != null) {
      // Keep original aspect ratio of the PNG file
      float aspectRatio = (float)dinoSprite.width / (float)dinoSprite.height;
      float displayHeight = size;
      float displayWidth = size * aspectRatio;
      
      // Center the image properly
      image(dinoSprite, x - displayWidth/2, y - displayHeight/2, displayWidth, displayHeight);
    } else {
      fill(dinoColor);
      // Simple dinosaur shape
      ellipse(x, y, size, size); // Body
      ellipse(x + 10, y - 10, 15, 15); // Head
      ellipse(x - 10, y + 5, 8, 8); // Tail
    }
    
    // Debug: Draw hit box
    if (debugMode) {
      noFill();
      stroke(255, 0, 0); // Red color
      strokeWeight(2);
      rect(x - size/2, y - size/2, size, size);
      strokeWeight(1);
    }
  }
  
  public boolean checkCollision(Obstacle obs) {
    // More precise collision detection with proper hit boxes
    float dinoLeft = x - size/2;
    float dinoRight = x + size/2;
    float dinoTop = y - size/2;
    float dinoBottom = y + size/2;
    
    float obsLeft = obs.x;
    float obsRight = obs.x + obs.width;
    float obsTop = obs.y;
    float obsBottom = obs.y + obs.height;
    
    // Check for collision with more precise hit boxes
    return (dinoRight > obsLeft && dinoLeft < obsRight &&
            dinoBottom > obsTop && dinoTop < obsBottom);
  }
  
  public void reset() {
    y = groundY - size/2; // Position so bottom touches ground
    velocity = 0;
    isJumping = false;
  }
}

// Obstacle class with proper hit boxes and random sizing
class Obstacle {
  float x, y;
  float width, height;
  float speed;
  boolean isBig; // Whether this is a big or small cactus
  float scale; // Random scale factor for visual variety
  
  Obstacle(float x, float groundY) {
    this.x = x;
    this.speed = gameSpeed;
    
    // Random size determination (30% big, 70% small)
    this.isBig = random(1) < 0.3f;
    
    // Fixed sizes for consistent hit boxes (no random scaling)
    if (isBig) {
      // Big cactus with consistent hit box
      this.width = 25; // Fixed width for all big cacti
      this.height = 35; // Fixed height for all big cacti
    } else {
      // Small cactus with consistent hit box
      this.width = 18; // Fixed width for all small cacti
      this.height = 25; // Fixed height for all small cacti
    }
    
    this.y = groundY - height; // Position so bottom touches ground
  }
  
  public void update() {
    x -= speed;
  }
  
  public void display() {
    // Use appropriate cactus sprite based on size, preserving original aspect ratio
    if (isBig && bigCactusSprite != null) {
      // Keep original aspect ratio with consistent sizing
      float aspectRatio = (float)bigCactusSprite.width / (float)bigCactusSprite.height;
      float displayHeight = height; // Use full hit box height for consistency
      float displayWidth = displayHeight * aspectRatio;
      
      // Center horizontally and anchor to ground
      float offsetX = (width - displayWidth) / 2;
      float offsetY = height - displayHeight; // Anchor to bottom of hit box (ground level)
      image(bigCactusSprite, x + offsetX, y + offsetY, displayWidth, displayHeight);
    } else if (!isBig && smallCactusSprite != null) {
      // Keep original aspect ratio with consistent sizing
      float aspectRatio = (float)smallCactusSprite.width / (float)smallCactusSprite.height;
      float displayHeight = height; // Use full hit box height for consistency
      float displayWidth = displayHeight * aspectRatio;
      
      // Center horizontally and anchor to ground
      float offsetX = (width - displayWidth) / 2;
      float offsetY = height - displayHeight; // Anchor to bottom of hit box (ground level)
      image(smallCactusSprite, x + offsetX, y + offsetY, displayWidth, displayHeight);
    } else {
      // Fallback to simple shapes if sprites not loaded
      fill(100, 50, 0); // Brown color for cactus
      rect(x, y, width, height);
      
      // Add some cactus details
      fill(0, 100, 0);
      rect(x + 5, y, 5, height);
      rect(x + 10, y, 5, height);
    }
    
    // Debug: Draw hit box
    if (debugMode) {
      noFill();
      stroke(255, 0, 0); // Red color
      strokeWeight(2);
      rect(x, y, width, height);
      strokeWeight(1);
      
      // Also show size info
      fill(255, 0, 0);
      textAlign(LEFT);
      textSize(10);
      text("W:" + PApplet.parseInt(width) + " H:" + PApplet.parseInt(height), x, y - 5);
    }
  }
}

// Cleanup Minim when game exits
public void stop() {
  if (jumpSound != null) {
    jumpSound.close();
  }
  if (collisionSound != null) {
    collisionSound.close();
  }
  if (minim != null) {
    minim.stop();
  }
  super.stop();
}


  public void settings() { size(800, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
